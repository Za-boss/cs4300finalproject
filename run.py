#!/usr/bin/env python3

import argparse
import random
from dataclasses import dataclass
from search import *
from colony_simulation.colony import *
from colony_simulation.building import *
from colony_simulation.wrapper import Colony_Wrapper
from colony_simulation.default_buildings import *
from colony_simulation.default_events import *


# goes through a list of events, if the event has firing date(s), 
# if the event has a firing likelihood, generate a random number and add the event at the current day if the random number deems it so
def setup_events(events : list[Event], days : int):
    
    event_list = []
    event_removal_list = []

    for event in events:
        if event.fire_dates:
            event_list.append(event)
            event_removal_list.append(event)
        if event.firing_likelihood:
            fire_dates = []
            for i in range(1, days + 1):
                if random.random() <= event.firing_likelihood:
                    fire_dates.append(i)
                    event.fire_count -= 1
                    if event.fire_count <= 0:
                        event_removal_list.append(event)
                        break
            event.firing_likelihood = None
            event.fire_dates = tuple(fire_dates)
            event_list.append(event)
    for event in event_removal_list:
        events.remove(event)
    return event_list



def setup_simulation(expected_days : int) -> tuple[Colony, list[Building]]:
    buildings = [farm.clone(), nuclear_reactor.clone()]
    available_buildings = [building for building in ALL_BUILDINGS]
    events = [event for event in ALL_EVENTS]
    event_list = setup_events(events, expected_days)
    colony_state = Colony(starting_buildings=buildings, events=event_list)

    return (colony_state, available_buildings)

algorithms = {
    "default_dfs" : default_dfs,
    "heuristic_dfs" : heuristic_dfs,
    "percentage_fuzzing" : percentage_fuzzing
}

@dataclass 
class Heuristic_Values:
    w_food: float
    w_energy: float
    w_defense: float
    w_population: float
    food_target_base: float
    energy_prod_target: float
    defense_target: float
    population_target: float
    efficiency_target: float
    below_efficiency_population_w: float
    below_food_target_food_w: float
    below_energy_target_energy_w: float

def make_heuristic_values() -> Heuristic_Values:
    return Heuristic_Values(
        w_food=2.0,
        w_energy=2.0,
        w_defense=1.3,
        w_population=2.0,
        food_target_base=300.0,
        energy_prod_target=250.0,
        defense_target=300.0,
        population_target=200.0,
        efficiency_target=0.8,
        below_efficiency_population_w=10.0,
        below_food_target_food_w=5.0,
        below_energy_target_energy_w=4.0
    )

def read_heuristic_weights(file_path: str) -> Heuristic_Values:
    weights = {}
    with open(file_path, 'r') as f:
        for line in f:
            key, value = line.strip().split('|')
            weights[key.strip()] = float(value.strip())
    return Heuristic_Values(
        w_food=weights.get('w_food', 2.0),
        w_energy=weights.get('w_energy', 2.0),
        w_defense=weights.get('w_defense', 1.3),
        w_population=weights.get('w_population', 2.0),
        food_target_base=weights.get('food_target_base', 300.0),
        energy_prod_target=weights.get('energy_prod_target', 250.0),
        defense_target=weights.get('defense_target', 300.0),
        population_target=weights.get('population_target', 200.0),
        efficiency_target=weights.get('efficiency_target', 0.8),
        below_efficiency_population_w=weights.get('below_efficiency_population_w', 10.0),
        below_food_target_food_w=weights.get('below_food_target_food_w', 5.0),
        below_energy_target_energy_w=weights.get('below_energy_target_energy_w', 4.0)
    )

def main() -> None:
    MAX_ACTIONS_PER_DAY = 6

    parser = argparse.ArgumentParser(description="Agent runner for running the colony management agent")
    parser.add_argument('--algorithm', '--algo', type=str, choices=algorithms.keys(), required=False, default="default_dfs", help="What algorithm to use for this run of the colony management agents")
    parser.add_argument('--run-count', "--rc", type=int, default=10, required=False, help="How many times the simulation should run, this should only be used when using the percentage fuzzing algorithm")
    parser.add_argument('--node-expansions-allowed', "--nea", type=int, default=500, required=False, help="How many nodes the agent gets to expand, only applies to the DFS searches")
    parser.add_argument('--seed', '--s', type=int, required=False, help="The seed for random number generation, if blank a seed is generated by the program")
    parser.add_argument('--display-timeline', '--dt', type=bool, required=False, default=False, help="Whether or not to display the timeline the agent followed to get to its conclusion")
    parser.add_argument('--actions-per-day', '--apd', type=int, required=False, default=3, help=f"How many actions per day the agent is allowed to take, the max is {MAX_ACTIONS_PER_DAY} action per day and the min is 1 action per day")
    parser.add_argument('--weight-file', '--wf', type=str, required=False, help="Path to a file containing heuristic weights to use for the agent")
    args = parser.parse_args()
    
    seed = args.seed
    if not seed:
        seed = random.randrange(10000000)
    random.seed(seed)
    print(f"Seed for this run: {seed}")

    algorithm = algorithms[args.algorithm]
    run_count = args.run_count
    node_expansions_allowed = args.node_expansions_allowed
    display_timeline = args.display_timeline
    actions_per_day = args.actions_per_day
    weight_file = args.weight_file

    if actions_per_day > MAX_ACTIONS_PER_DAY:
        print(f"Too many actions per day, clamping to {MAX_ACTIONS_PER_DAY}")
        actions_per_day = MAX_ACTIONS_PER_DAY
    actions_per_day = max(1, actions_per_day)

    GOAL_DAYS = 31
    colony, buildings = setup_simulation(GOAL_DAYS)
    if not weight_file:
        heuristic_weights = make_heuristic_values()
    else:
        heuristic_weights = read_heuristic_weights(weight_file)
    colony_wrapper = Colony_Wrapper(colony, buildings, heuristic_weights)
    colony_wrapper.actions_per_day = actions_per_day
    colony_wrapper.goal_day = GOAL_DAYS

    if args.algorithm == "percentage_fuzzing":
        stats = algorithm(colony_wrapper, run_count)
        print(f"""Percentage fuzzing stats:
                Win rate: {stats.win_rate}
                Total wins: {stats.total_wins}
                Total runs: {stats.total_runs}
                Total depth: {stats.total_depth}
                Average depth: {stats.average_depth}
                Nodes generated: {stats.nodes_generated}""")
        return
    
    path, stats = algorithm(colony_wrapper, node_expansions_allowed = node_expansions_allowed)
    print(f"""Search stats:
                Attempts needed: {stats.attempts_needed}
                Nodes generated: {stats.nodes_generated}
                Nodes explored: {stats.nodes_explored}
                Average depth: {stats.average_depth}
                Success: {stats.success}""")
    if not display_timeline:
        return
    
    print("Colony timeline:")
    for day, node in enumerate(path):
        print(day)
        print(f"Actions: {node.actions}")
        print(f"Energy: {node.state.energy}")
        print(f"Base energy production: {node.state.base_energy_production}")
        print(f"Population: {node.state.population}")
        print(f"Population growth factor: {node.state.population_growth_factor}")
        print(f"Defense: {node.state.defense_capacity}")
        print(f"Food: {node.state.food}")
        print(f"Base food production: {node.state.base_food_production}")
        print(f"Total buildings: {len(node.state.buildings)}")
        if node.state.buildings:
            print(f"Building Efficiency: {node.state.buildings[0].power_modifier}")


        print("Events:")
        for event in colony.events:
            if not event.fire_dates:
                continue
            if day in event.fire_dates:
                print(event.event_name)

    #Start by implementing a basic version of the "fuzzer" which is basic DFS first

if __name__ == "__main__":

    main()